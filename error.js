/*1. Исключения
    Наиболее распространенный способ устранения ошибок функциями — их генерация.
    Когда вы выдаете ошибку, она становится исключением и должна быть перехвачена где-то в стеке с помощью блока try/catch. Если ошибка может всплывать в стеке без обнаружения,
    она становится uncaughtException,
    что приводит к преждевременному завершению работы приложения. Например, встроенный метод JSON.parse() выдает ошибку, если его строковый аргумент не является допустимым
    объектом JSON.
*/

    function parseJSON(data) {
        return JSON.parse(data);
    }

    try {
        const result = parseJSON('A string');

        console.log(result);
    } catch (err) {
        console.log(err.message); // Unexpected token A in JSON at position 0
    }

// Чтобы использовать этот шаблон в своих функциях, все, что вам нужно сделать, это добавить ключевое слово throw перед экземпляром ошибки.
//  Этот шаблон сообщения об ошибках и их обработки идиоматичен для функций, выполняющих синхронные операции.

    function square(num) {
        if (typeof num !== 'number') {
            throw new TypeError(`Expected number but got: ${typeof num}`);
        }

        return num * num;
    }

    try {
        square('8');
    } catch (err) {
        console.log(err.message); // Expected number but got: string
    }

/*
    2. Обратные вызовы с ошибкой
    Из-за своей асинхронной природы Node.js широко использует функции обратного вызова для большей части обработки ошибок. Функция обратного вызова передается в качестве
    аргумента
    другой функции и выполняется, когда функция завершает свою работу. Если вы какое-то время писали код JavaScript, вы, вероятно, знаете, что шаблон обратного вызова широко
    используется во всем коде JavaScript.

        Node.js использует в большинстве своих асинхронных методов соглашение об обратном вызове «сначала ошибка», чтобы убедиться, что ошибки проверяются должным образом
        до того,
        как будут использованы результаты операции. Эта функция обратного вызова обычно является последним аргументом функции, инициирующей асинхронную операцию, и вызывается
        один раз
        при возникновении ошибки или при получении результата операции. Ее подпись показана ниже:

        function (err, result) {}
        */
    // Первый аргумент зарезервирован для объекта ошибки. Если в ходе асинхронной операции возникает ошибка, она будет доступна через аргумент err и result будет иметь
    // значение undefined.
    // Однако, если ошибки не возникнет err будет null или undefined и result будет содержать ожидаемый результат операции. Этот шаблон можно продемонстрировать, прочитав
    // содержимое
    // файла с помощью встроенного метода fs.readFile():

    const fs = require('fs');

    fs.readFile('/path/to/file.txt', (err, result) => {
        if (err) {
            console.error(err);
            return;
        }

        // Log the file contents if no error
        console.log(result);
    });

    // Как вы можете видеть метод readFile() ожидает функцию обратного вызова в качестве своего последнего аргумента, который придерживается описанной ранее сигнатуры функции
    // "сначала ошибка". В этом сценарии аргумент result содержит содержимое прочитанного файла, если не возникает ошибки. В противном случае undefined и аргумент err
    // заполняется объектом ошибки, содержащим информацию о проблеме (например, файл не найден или недостаточные разрешения).

   // Как правило, методы, которые используют этот шаблон обратного вызова для доставки ошибок, не могут знать, насколько важна ошибка, которую они производят, для вашего
    // приложения. Это может быть серьезным или тривиальным. Вместо того, чтобы принимать решение самостоятельно, ошибка отправляется вам для обработки. Важно контролировать
    // поток содержимого функции обратного вызова, всегда проверяя наличие ошибки перед попыткой доступа к результату операции. Игнорировать ошибки небезопасно, и вы не должны
    // доверять содержимому result перед проверкой ошибок.

        // Если вы хотите использовать этот шаблон обратного вызова с первой ошибкой в ​​своих собственных асинхронных функциях, все, что вам нужно сделать, это принять функцию
    // в качестве последнего аргумента и вызвать ее, как показано ниже:

    function square(num, callback) {
        if (typeof callback !== 'function') {
            throw new TypeError(`Callback must be a function. Got: ${typeof callback}`);
        }

        // simulate async operation
        setTimeout(() => {
            if (typeof num !== 'number') {
                // if an error occurs, it is passed as the first argument to the callback
                callback(new TypeError(`Expected number but got: ${typeof num}`));
                return;
            }

            const result = num * num;
            // callback is invoked after the operation completes with the result
            callback(null, result);
        }, 100);
    }

    // Любому вызывающему объекту этой функции square потребуется передать функцию обратного вызова, чтобы получить доступ к ее результату или ошибке. Обратите внимание,
    // что во время выполнения возникает исключение, если аргумент обратного вызова не является функцией.

    square('8', (err, result) => {
        if (err) {
            console.error(err)
            return
        }

        console.log(result);
    });

    //Вам не нужно напрямую обрабатывать ошибку в функции обратного вызова. Вы можете распространить его вверх по стеку, передав его другому обратному вызову, но
    // не генерируйте исключение из функции, потому что оно не будет перехвачено, даже если вы окружите код блоком try/catch. Асинхронное исключение невозможно перехватить,
    // поскольку окружающий блок try/catch завершается до выполнения обратного вызова. Таким образом, исключение будет распространяться на вершину стека, вызывая с
    // бой приложения, если для него не зарегистрирован обработчик process.on('uncaughtException'), который будет обсуждаться позже.

    try {
        square('8', (err, result) => {
            if (err) {
                throw err; // not recommended
            }

            console.log(result);
        });
    } catch (err) {
        // This won't work
        console.error("Caught error: ", err);
    }

// 3. Отказ от промисов
// Промисы — это современный способ выполнения асинхронных операций в Node.js, и в настоящее время они обычно предпочтительнее обратных вызовов,
// потому что этот подход имеет лучший поток, который соответствует тому, как мы анализируем программы, особенно с шаблоном async/await.
// Любой API-интерфейс Node.js, который использует обратные вызовы для асинхронной обработки ошибок, может быть преобразован в промисы
// с помощью встроенного метода util.promisify(). Например, вот как можно использовать метод fs.ReadFile() для использования промисов:

    // const fs = require('fs');
    const util = require('util');

    const readFile = util.promisify(fs.readFile);

// Переменная ReadFile - это обещанная версия fs.ReadFile(), в которой отклонения промисов используются для сообщения об ошибках.
// Эти ошибки могут быть обнаружены с помощью метода цепочки catch, как показано ниже:

    readFile('/path/to/file_YYYYYYYYYYYYYYYYY.txt')
        .then((result) => console.log(result))
        .catch((err) => console.error(err));

// Вы также можете использовать обещанные API в  функции async, такой как показанна ниже. Это преобладающий способ использования обещаний в современном JavaScript,
// потому что код читается как синхронный код, а для обработки ошибок можно использовать знакомый механизм try/catch.
// Важно использовать await перед асинхронным методом, чтобы промис был выполнен (выполнен или отклонен) до того, как функция возобновит свое выполнение.
// Если промис отклоняется, выражение await выдает отклоненное значение, которое впоследствии перехватывается в окружающем блоке catch

    (async function callReadFile() {
        try {
            const result = await readFile('/path/to/file.txt');
            console.log(result);
        } catch (err) {
            console.error({ 'err async': err });
        }
    })();

// Вы можете использовать промисы в своих асинхронных функциях, возвращая промис из функции и помещая код функции в обратный вызов промиса.
// Если есть ошибка, reject с объектом Error. В противном случае resolve промис с результатом, чтобы оно было доступно в цепочке метода .then
// или непосредственно в качестве значения функции async при использовании async/await.

    function square__(num) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if (typeof num !== 'number') {
                    reject(new TypeError(`Expected number but got: ${typeof num}`));
                }

                const result = num * num;
                resolve(result);
            }, 100);
        });
    }

    square__(77)
        .then((result) => console.log(result))
        .catch((err) => console.error(err));
